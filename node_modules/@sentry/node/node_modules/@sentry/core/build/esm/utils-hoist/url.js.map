{"version":3,"file":"url.js","sources":["../../../src/utils-hoist/url.ts"],"sourcesContent":["type PartialURL = {\n  host?: string;\n  path?: string;\n  protocol?: string;\n  relative?: string;\n  search?: string;\n  hash?: string;\n};\n\ninterface URLwithCanParse extends URL {\n  canParse: (url: string, base?: string | URL | undefined) => boolean;\n}\n\n// A subset of the URL object that is valid for relative URLs\n// The URL object cannot handle relative URLs, so we need to handle them separately\ntype RelativeURL = {\n  isRelative: true;\n  pathname: URL['pathname'];\n  search: URL['search'];\n  hash: URL['hash'];\n};\n\ntype URLObject = RelativeURL | URL;\n\n// Curious about `thismessage:/`? See: https://www.rfc-editor.org/rfc/rfc2557.html\n//  > When the methods above do not yield an absolute URI, a base URL\n//  > of \"thismessage:/\" MUST be employed. This base URL has been\n//  > defined for the sole purpose of resolving relative references\n//  > within a multipart/related structure when no other base URI is\n//  > specified.\n//\n// We need to provide a base URL to `parseStringToURLObject` because the fetch API gives us a\n// relative URL sometimes.\n//\n// This is the only case where we need to provide a base URL to `parseStringToURLObject`\n// because the relative URL is not valid on its own.\nconst DEFAULT_BASE_URL = 'thismessage:/';\n\n/**\n * Checks if the URL object is relative\n *\n * @param url - The URL object to check\n * @returns True if the URL object is relative, false otherwise\n */\nexport function isURLObjectRelative(url: URLObject): url is RelativeURL {\n  return 'isRelative' in url;\n}\n\n/**\n * Parses string to a URL object\n *\n * @param url - The URL to parse\n * @returns The parsed URL object or undefined if the URL is invalid\n */\nexport function parseStringToURLObject(url: string, urlBase?: string | URL | undefined): URLObject | undefined {\n  const isRelative = url.startsWith('/');\n  const base = urlBase ?? (isRelative ? DEFAULT_BASE_URL : undefined);\n  try {\n    // Use `canParse` to short-circuit the URL constructor if it's not a valid URL\n    // This is faster than trying to construct the URL and catching the error\n    // Node 20+, Chrome 120+, Firefox 115+, Safari 17+\n    if ('canParse' in URL && !(URL as unknown as URLwithCanParse).canParse(url, base)) {\n      return undefined;\n    }\n\n    const fullUrlObject = new URL(url, base);\n    if (isRelative) {\n      // Because we used a fake base URL, we need to return a relative URL object.\n      // We cannot return anything about the origin, host, etc. because it will refer to the fake base URL.\n      return {\n        isRelative,\n        pathname: fullUrlObject.pathname,\n        search: fullUrlObject.search,\n        hash: fullUrlObject.hash,\n      };\n    }\n    return fullUrlObject;\n  } catch {\n    // empty body\n  }\n\n  return undefined;\n}\n\n/**\n * Takes a URL object and returns a sanitized string which is safe to use as span name\n * see: https://develop.sentry.dev/sdk/data-handling/#structuring-data\n */\nexport function getSanitizedUrlStringFromUrlObject(url: URLObject): string {\n  if (isURLObjectRelative(url)) {\n    return url.pathname;\n  }\n\n  const newUrl = new URL(url);\n  newUrl.search = '';\n  newUrl.hash = '';\n  if (['80', '443'].includes(newUrl.port)) {\n    newUrl.port = '';\n  }\n  if (newUrl.password) {\n    newUrl.password = '%filtered%';\n  }\n  if (newUrl.username) {\n    newUrl.username = '%filtered%';\n  }\n\n  return newUrl.toString();\n}\n\n/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nexport function parseUrl(url: string): PartialURL {\n  if (!url) {\n    return {};\n  }\n\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    search: query,\n    hash: fragment,\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nexport function stripUrlQueryAndFragment(urlPath: string): string {\n  return (urlPath.split(/[?#]/, 1) as [string, ...string[]])[0];\n}\n\n/**\n * Takes a URL object and returns a sanitized string which is safe to use as span name\n * see: https://develop.sentry.dev/sdk/data-handling/#structuring-data\n */\nexport function getSanitizedUrlString(url: PartialURL): string {\n  const { protocol, host, path } = url;\n\n  const filteredHost =\n    host\n      // Always filter out authority\n      ?.replace(/^.*@/, '[filtered]:[filtered]@')\n      // Don't show standard :80 (http) and :443 (https) ports to reduce the noise\n      // TODO: Use new URL global if it exists\n      .replace(/(:80)$/, '')\n      .replace(/(:443)$/, '') || '';\n\n  return `${protocol ? `${protocol}://` : ''}${filteredHost}${path}`;\n}\n"],"names":[],"mappings":"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"}